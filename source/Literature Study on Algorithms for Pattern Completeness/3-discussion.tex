\section{Discussion} \label{discussion}
Both algorithms presented by Thiemann and Yamada in \cite{thiemann} and by Lazrek et al. in \cite{lazrek} are able to decide whether a given term rewrite system is pattern complete. The focus of the complement algorithm is to conclude relative completeness, however, one can make use of $N_{last}$ to conclude whether the program is also pattern complete. Namely, when that is not empty, the set contains the patterns where the program still needs to be defined. One notable difference between the two algorithms is that the refined version of Thiemann and Yamada's proven to work with non-linear patterns, whereas, the algorithm by Lazrek et al. might not. The paper by Lazrek et al. mentions certain examples of non-linearity where the algorithm successfully completes, but also in cases where it would get stuck.

Another aspect that makes the complement algorithm interesting is its ability of counterexample generation. By default the contents of $N_{last}$, after checking for irreducibility, contains the patterns where the function $f$ still needs to be defined\cite{lazrek}. The algorithm by Thiemann and Yamada, by default, does not have this ability â€“ though it is mentioned as an easy improvement in the paper\cite{thiemann}.

Tree automata have proven useful for deciding pattern completeness and related notions, but current algorithms e.g. in \cite{middeldorp} are restricted to left-linear systems.

One question that might arise after reviewing the above papers, is that it remains to be seen how these algorithms would perform on a more exhaustive performance testing against each other. Namely, the examples created by Thiemann and Yamada clearly give the upper hand to their algorithm\cite{thiemann}, however, their method of example generation seems a bit contrived. One might wonder how the algorithms would fare on more "typical" inputs such as small functional programs from existing projects. Moreover, the algorithms the Thiemann and Yamada paper check against are not implemented or in any case tuned by the authors, but are being used from 3rd party tools such as the ground confluence prover of Aoto and Toyama \cite{aoto}, or the tree automata framework developed by Middeldorp et al.\cite{middeldorp}. This fact might explain the constant factor performance difference between the runtimes.

Finally, as suggested by Thiemann and Yamada, it remains to be seen whether their algorithm can be adjusted to decide quasi-reducibility, or whether a similar syntax-directed algorithm can be constructed.